Blame					T_GIT_REF
Blame_Hunk				T_GIT_REF
Blob					T_GIT_REF
Branch					T_GIT_REF
Commit					T_GIT_REF
Config					T_GIT_REF
Cred					T_GIT_REF
Diff					T_GIT_REF
Diff_Delta				T_GIT_REF
Diff_File				T_GIT_REF
Diff_Hunk				T_GIT_REF
Filter					T_GIT_REF
Filter_Source			T_GIT_REF
Index					T_GIT_REF
Index_Entry				T_GIT_REF
Patch					T_GIT_REF
Push					T_GIT_REF
Reflog					T_GIT_REF
RefSpec					T_GIT_REF
Reference				T_GIT_REF
Remote					T_GIT_REF
Repository				T_GIT_REPOSITORY
Signature				T_GIT_REF
Tag					T_GIT_REF
Tree					T_GIT_REF
Tree_Builder				T_GIT_REF
Tree_Entry				T_GIT_REF
Walker					T_GIT_REF

OUTPUT
T_GIT_REF
	{
		git_double_pointer d = malloc(sizeof *d);

		d->p = (void *) $var;
		d->repo = NULL;
		sv_setref_pv($arg, \"Git::Raw::${(my $ntt = $ntype) =~ s/_/::/g;\$ntt}\", (void *) d);
	}

INPUT
T_GIT_REF
	if (sv_isobject($arg) &&
	    sv_derived_from($arg, \"Git::Raw::${(my $ntt = $ntype) =~ s/_/::/g;\$ntt}\")) {
		git_double_pointer d = INT2PTR(git_double_pointer, SvIV((SV *) SvRV($arg)));

		$var = ($type) d->p;
	} else
		Perl_croak(aTHX_ \"$var is not of type Git::Raw::${(my $ntt = $ntype) =~ s/_/::/g;\$ntt}\");

OUTPUT
T_GIT_REPOSITORY
	sv_setref_pv($arg, \"Git::Raw::${(my $ntt = $ntype) =~ s/_/::/g;\$ntt}\", (void *) $var);

INPUT
T_GIT_REPOSITORY
	if (sv_isobject($arg) &&
	    sv_derived_from($arg, \"Git::Raw::${(my $ntt = $ntype) =~ s/_/::/g;\$ntt}\"))
		$var = INT2PTR($type, SvIV((SV *) SvRV($arg)));
	else
		Perl_croak(aTHX_ \"$var is not of type Git::Raw::${(my $ntt = $ntype) =~ s/_/::/g;\$ntt}\");
